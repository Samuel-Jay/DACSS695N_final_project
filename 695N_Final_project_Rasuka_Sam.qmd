---
title: "Spotify Artist Feature Collaboration Network Analysis"
subtitle: "DACSS 695N Social Network Analysis"
author: "Rasuka Shrestha/ Samuel Jayachandran"
date: "April 25, 2024"
format: 
  html:
    toc: true
    toc-depth: 2
    toc-title: Contents
    toc-location: left
    code-fold: false
    html-math-method: katex
    theme: flatly
    smooth-scroll: true
    link-external-icon: true
    link-external-newwindow: true
    citations-hover: true
    footnotes-hover: true
    font-size: 80%
editor: visual
---

# Spotify artist feature collaboration network analysis

## Introduction:

This study is a network analysis that tries to identify, quantify and evaluate the relationship between follower counts of each artist's various collaborators vs the artist's own success in the charts. The presumed hypothesis is that popular artists will probably have many successful chart hits (hence why they're popular), therefore any successful/complete collaboration that another artist has with them for an album is likely to reach very high in an extremely competitive chart ranking.

```{r}
library(moderndive)
library(olsrr)
library(tidyr)
library(tidyverse)
library(sna)
library(igraph)
library(network)
library(infer)
library(intergraph)
library(stringr)
library(readr)
library(ggnetwork)
```

These are the necessary packages to do our network analysis.

Charting high in an under-competitive ranking is not the same as ranking high in a highly competitive chart. So rank values should be weighted by the competitiveness. It is logical to assume that a ranking is competitive if: 1) that genre of music is highly popular, 2) the artists are highly popular, 3) due to 1 and 2 there would be a massive influx of many artists to that category/genre and also to that particular chart's song collection.

Assessing the competitiveness in a numerical manner requires another metric involving popularity/follower counts of artists, and number of artists producing music in that genre.

### Data cleaning

```{r}
edges <- read_csv("edges.csv")
edges <- na.omit (edges)

nodes <- read.csv("nodes.csv")
nodes <- na.omit (nodes)
nodes <- nodes %>% distinct(spotify_id, .keep_all = TRUE)

# hiphop <- left_join(edges, nodes, by = join_by(id_0 == spotify_id))
# hiphop <- left_join(hiphop, nodes, by = join_by(id_1 == spotify_id))
# hiphop <- hiphop %>% filter(((str_detect(genres.x, "hip hop")) | (str_detect(genres.y, "hip hop"))) &
#                             ((str_detect(chart_hits.x, "us")) | (str_detect(chart_hits.y, "us"))))

# pop <- left_join(edges, nodes, by = join_by(id_0 == spotify_id))
# pop <- left_join(pop, nodes, by = join_by(id_1 == spotify_id))
# pop <- pop %>% filter(((str_detect(genres.x, "pop")) | (str_detect(genres.y, "pop"))) &
#                             ((str_detect(chart_hits.x, "us")) | (str_detect(chart_hits.y, "us"))))

HP <- nodes %>% filter(((str_detect(genres, "hip hop")) | str_detect(genres, "pop")) & (str_detect(chart_hits, "us")))

```

### First problem:

```{r}
full_net <- graph_from_edgelist(as.matrix(edges))
mean(degree(full_net))
```

There are 153k nodes/artists in the network and 300k collaborations between them, the average degree of the network from the edgelist should be less than 2 (it says 3.918 up there). The node attribute list has 156k entries, don't know if they are duplicates or artists who just didn't collaborate with anyone.

<<<<<<< HEAD
## Converting to 2-mode network to compare in-genre collab rate vs cross-genre collab:

We will now take the subgenres of hip hop and pop and look at which artists belong to which subgenres. Then we can compare the collaboration within hiphop vs between hiphop and pop. We can also then compare the popularity of in-genre collaborators vs cross-genre collaborators.

```{r}
genre_el <- as.matrix(data.frame(HP[2], HP[5], HP[3]))
genre_net <- graph_from_data_frame(genre_el, directed = FALSE)

V(genre_net)$genre <- ifelse(str_detect(genre_el[2], "hip hop"), TRUE, FALSE)

genre_net
```

```{r}
# HOW TO FIX MARGINS AND SPACING BETWEEN NODES:

par(mar = c(,,,,))
V(genre_net)$color <- ifelse(V(genre_net)$genre, "pink", "yellow")
V(genre_net)$shape <- ifelse(V(genre_net)$genre, "circle", "square")
E(genre_net)$color <- "lightgray"

plot(genre_net,rescale = TRUE,
    # ylim=c(100,400), xlim=c(-1700,2400), asp = 0, # Play around with the ylim and xlim numbers here for aesthetics please
     vertex.label = NA,
     vertex.label.color = "black",
     layout = layout_nicely)

plot(genre_net,
     vertex.label = NA,
     layout = layout_as_bipartite(genre_net, types = V(genre_net)$genre))

```
```{r}
# Set margins for the plot
par(mar = c(5, 5, 4, 4))

# Assign colors to vertices based on genre attribute
V(genre_net)$color <- ifelse(V(genre_net)$genre, "pink", "yellow")

# Set shapes of vertices based on genre attribute
V(genre_net)$shape <- ifelse(V(genre_net)$genre, "circle", "square")

# Set color of edges
E(genre_net)$color <- "lightgray"

# Plot the network graph with a different layout for more spacing
plot(genre_net,
     rescale = TRUE, # Rescale plot to fit all vertices
     vertex.label = NA, # Hide vertex labels
     vertex.label.color = "black", # Set color of vertex labels
     layout = layout_with_fr) # Use Fruchterman-Reingold layout for more spacing

```

=======
>>>>>>> 1825fabd572f63b14ee44babe14607727ca4ba0f
### Analysis here:

## Python-processed adjacency matrix of each artist analyzed here:

```{r}
edges <- edges %>% filter((edges$id_0 %in% HP$spotify_id) &
                            (edges$id_1 %in% HP$spotify_id))

# all_names <- unique(c(collaborations$from, collaborations$to))
# 
# # Create an empty adjacency matrix
# adj_matrix <- matrix(0, nrow = length(all_names), ncol = length(all_names), dimnames = list(all_names, all_names))
# 
# # Fill in the adjacency matrix based on collaborations
# for (i in 1:nrow(collaborations)) {
#   from <- collaborations$from[i]
#   to <- collaborations$to[i]
#   adj_matrix[from, to] <- 1
#   adj_matrix[to, from] <- 1 # Uncomment if collaboration is bidirectional
# }
# 
# # Print the adjacency matrix
# print(adj_matrix)

# Get unique collaborations and their frequencies
unique_collaborations <- table(paste(edges$id_0, edges$id_1))

# Get unique names of individuals
all_names <- unique(c(edges$id_0, edges$id_1))

# Create an empty adjacency matrix
adj_matrix <- matrix(0, nrow = length(all_names), ncol = length(all_names), dimnames = list(all_names, all_names))

# Fill in the adjacency matrix with collaboration frequencies
for (collab in names(unique_collaborations)) {
  names <- unlist(strsplit(collab, " "))
  from <- names[1]
  to <- names[2]
  adj_matrix[from, to] <- unique_collaborations[collab]
  adj_matrix[to, from] <- unique_collaborations[collab]
}

# Print the adjacency matrix
# print(adj_matrix)
```

```{r}
collab_graph <- graph_from_adjacency_matrix(adj_matrix, mode = "undirected",
                                            diag = FALSE)
```

```{r}
HP <- HP %>% filter(HP$spotify_id %in% all_names)

V(collab_graph)$name <- HP$name
V(collab_graph)$followers <- HP$followers
```

```{r}
plot(collab_graph, 
     vertex.size = 0.25,
     vertex.label.cex = 0.25,
     layout = layout_with_fr(collab_graph) # consider layout_with_drl or layout_with_spectral
     )
```

## Considerations that were impractical or not possible:

We were unable to get datasets where we could find the time of each collab between any combination of artists. So we cannot analyze temporal changes in relationships, how artist popularity changed with various collaborations etc.,.

With greater time, more access to Spotify APIs, we would be able to obtain time of each collaboration using the artists' ids, matching the name of the album/single (that the artists collaborated on) to the year that the particular album/single was released.

Then we could make comparisons between the follower count of each of the artists before and after the collaboration was done. This could be done with networkDynamic package and viewing the network before and after each new edge is formed between 2 artists.
