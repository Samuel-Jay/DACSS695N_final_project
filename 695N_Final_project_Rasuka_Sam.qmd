---
title: "Final Project"
subtitle: "DACSS 695N Social Network Analysis"
author: "Rasuka Shrestha/ Samuel Jayachandran"
date: "April 25, 2024"
format: 
  html:
    toc: true
    toc-depth: 2
    toc-title: Contents
    toc-location: left
    code-fold: false
    html-math-method: katex
    theme: flatly
    smooth-scroll: true
    link-external-icon: true
    link-external-newwindow: true
    citations-hover: true
    footnotes-hover: true
    font-size: 80%
editor: visual
---

# Spotify artist feature collaboration network analysis

## Introduction:

This study is a network analysis that tries to identify, quantify and evaluate the relationship between follower counts of each artist's various collaborators vs the artist's own success in the charts. The presumed hypothesis is that popular artists will probably have many successful chart hits (hence why they're popular), therefore any successful/complete collaboration that another artist has with them for an album is likely to reach very high in an extremely competitive chart ranking.

```{r}
library(moderndive)
library(olsrr)
library(tidyr)
library(tidyverse)
library(sna)
library(igraph)
library(network)
library(infer)
library(intergraph)
library(stringr)
```

These are the necessary packages to do our network analysis.

Charting high in an under-competitive ranking is not the same as ranking high in a highly competitive chart. So rank values should be weighted by the competitiveness. It is logical to assume that a ranking is competitive if: 1) that genre of music is highly popular, 2) the artists are highly popular, 3) due to 1 and 2 there would be a massive influx of many artists to that category/genre and also to that particular chart's song collection.

Assessing the competitiveness in a numerical manner requires another metric involving popularity/follower counts of artists, and number of artists producing music in that genre.

### Caveat:

There is the possibility of high covariance between our Dependent Variable: chart hit score, and the Independent Variable: popularity-weighted degree of collaborations, since both use follower counts as a parameter in their metrics.

### Data cleaning:

```{r}
edges <- read_csv("DACSS695N_final_project/edges.csv")
edges<- na.omit (edges)
head(edges)

nodes <- read.csv("DACSS695N_final_project/nodes.csv")
nodes <- na.omit (nodes)
head(nodes)

spotifyartistdata <- read.csv("DACSS695N_final_project/spotify_artist_data.csv")
spotifyartistdata <- na.omit (spotifyartistdata)
head(spotifyartistdata)

#filtering it to 'hip hop' genre 
hiphop <- nodes |>
  filter(str_detect (genres, "hip hop"))

# chart hits based on us
hiphop <- nodes |>
  filter(str_detect (chart_hits, "us"))
```

## Considerations that were impractical or not possible:

We were unable to get datasets where we could find the time of each collab between any combination of artists. So we cannot analyze temporal changes in relationships.

With greater time, more access to Spotify APIs, we would be able to obtain time of each collaboration using the artists' ids, matching the name of the album/single (that the artists collaborated on) to the year that the particular album/single was released.

Then we could make comparisons between the follower count of each of the artists before and after the collaboration was done.

```{r}
library(intergraph)
library(network)
library(networkDynamic)
library(ggnetwork)

y7am <- which(hp_all_attrs[, "schoolyear"] <= 1987)
hp3n1 <- graph_from_adjacency_matrix(as.matrix(hp3.am[y7am, y7am]))
hp3n1 <- asNetwork(hp3n1)

y67am <- which(hp_all_attrs[, "schoolyear"] <= 1988)
hp3n2 <- graph_from_adjacency_matrix(as.matrix(hp3.am[y67am, y67am]))
hp3n2 <- asNetwork(hp3n2)

y567am <- which(hp_all_attrs[, "schoolyear"] <= 1989)
hp3n3 <- graph_from_adjacency_matrix(as.matrix(hp3.am[y567am, y567am]))
hp3n3 <- asNetwork(hp3n3)

y4567am <- which(hp_all_attrs[, "schoolyear"] <= 1990)
hp3n4 <- graph_from_adjacency_matrix(as.matrix(hp3.am[y4567am, y4567am]))
hp3n4 <- asNetwork(hp3n4)

y34567am <- which(hp_all_attrs[, "schoolyear"] <= 1991)
hp3n5 <- graph_from_adjacency_matrix(as.matrix(hp3.am[y34567am, y34567am]))
hp3n5 <- asNetwork(hp3n5)

y234567am <- which(hp_all_attrs[, "schoolyear"] <= 1993)
hp3n6 <- graph_from_adjacency_matrix(as.matrix(hp3.am[y234567am, y234567am]))
hp3n6 <- asNetwork(hp3n6)

y1234567am <- which(hp_all_attrs[, "schoolyear"] <= 1995)
hp3n7 <- graph_from_adjacency_matrix(as.matrix(hp3.am[y1234567am, y1234567am]))
hp3n7 <- asNetwork(hp3n7)

hpnty <- networkDynamic(network.list = list(hp3n1, hp3n2, hp3n3, hp3n4, hp3n5, hp3n6, hp3n7),
                        vertex.pid = "vertex.names",
                        create.TEAs = T)

hpnty <- get.networks(hpnty,
                      start = 0,
                      end = 7,
                      time.increment = 1)

par(mfrow = c(5, 2))

plot(hpnty[[1]], main = "Oldest students only", 
     vertex.col = "red", vertex.cex = 2)

plot(hpnty[[2]], main="6th and 7th years only",
     vertex.col = "red", vertex.cex = 2)

plot(hpnty[[3]], main="5th, 6th and 7th years only",
     vertex.col = "red", vertex.cex = 2)

plot(hpnty[[4]], main="4th, 5th, 6th and 7th years only",
     vertex.col = "red", vertex.cex = 2)

plot(hpnty[[5]], main="3rd, 4th, 5th, 6th and 7th years only",
     vertex.col = "red", vertex.cex = 2)

plot(hpnty[[6]], main="Everyone but 1st years",
     vertex.col = "red", vertex.cex = 2)

plot(hpnty[[2]], main="All Hogwarts students",
     vertex.col = "red", vertex.cex = 2)
```

```{r}
par(mfrow = c(4, 2))

locs <- network.layout.fruchtermanreingold(hpnty[[7]], layout.par = NULL)

plot(hpnty[[1]], main = "Oldest students only", 
     vertex.col = "red", vertex.cex = 2, coord = locs)

plot(hpnty[[2]], main="6th and 7th years only",
     vertex.col = "red", vertex.cex = 2, coord = locs)

plot(hpnty[[3]], main="5th, 6th and 7th years only",
     vertex.col = "red", vertex.cex = 2, coord = locs)

plot(hpnty[[4]], main="4th, 5th, 6th and 7th years only",
     vertex.col = "red", vertex.cex = 2, coord = locs)

plot(hpnty[[5]], main="3rd, 4th, 5th, 6th and 7th years only",
     vertex.col = "red", vertex.cex = 2, coord = locs)

plot(hpnty[[6]], main="Everyone but 1st years",
     vertex.col = "red", vertex.cex = 2, coord = locs)

plot(hpnty[[2]], main="All Hogwarts students",
     vertex.col = "red", vertex.cex = 2, coord = locs)
```

We can also use properties of the ego networks as predictors of other outcomes of interest. For example, let's try and predict the variable `HAPPY` using the features of the ego networks. Are individuals with larger ego networks happier? Does the composition of the ego network matter?

`Happy` is coded as a 1 (very happy), 2 (pretty happy), 3 (not too happy). Let's add a label to the variable and reorder it to run from not happy to happy.

```{r}

V(hp3.ig)$color <- factor(hp3.ig$year, levels = c("violet", "grey", "blue", "green", "yellow", "orange", "red"), 
                            labels = c("7th year", "6th year", "5th year", "4th year", "3rd year", "2nd year", "1st year"))

plot(hp3.ig,
     coords = locs,
     layout = layout_with_mds,
     vertex.color = V(hp3.ig)$color)
```

With this longer time period of aggregation, we begin to see groups emerge which was less possible when the aggregated intervals were only a minute. Finally, we can continue to use 10 minutes to aggregate the edges but set the interval to 1. In this case, rather than just doing 0-10, 10-20, 20-30, 30-40, the movie will do 0-10, 1-11, 2-12, etc. moving the interval up by 1 in each layout.

```         
{r}

slice.par <- list(start = 0, end = 43, interval = 1, 
                  aggregate.dur = 10, rule = "latest")

set.network.attribute(net_dynamic_interactions, 'slice.par', slice.par)

render.d3movie(net_dynamic_interactions, displaylabels = FALSE, 
               vertex.cex = 1.5, vertex.col = cols, 
               output.mode = "HTML", filename = "classroom_movie5.html")
```

We will begin by constructing the network assuming that the researcher deals with the missing data by performing listwise deletion. In this case, all of the missing nodes are dropped from the network when constructing the network object. This means that all ties from non-missing nodes to missing nodes will also not be included in the network. Let's create a matrix that just includes the non-missing nodes. Note that the syntax below uses the `-` sign to tell R which rows and columns in the matrix should be removed, here those cases that are missing.

```         
matrix_remove_missing <- sorority_matrix[-missing, -missing]
```

```         
dim(matrix_remove_missing)
```

```         
## [1] 58 58
```

Now there are only 58 rows and 58 columns as the 14 missing cases have been removed. We will now take our reduced matrix (with only non-missing cases) and create an igraph object.

```         
library(igraph)
```

```         
net_listwise_delete  <- graph_from_adjacency_matrix(matrix_remove_missing, 
                                                    mode = "directed")
```

Let's go ahead and plot the network with the missing nodes removed, adding a few plotting options to make the graph easier to interpret.

```         
plot(net_listwise_delete, vertex.label = NA, vertex.size = 10, 
     edge.arrow.size = .5, edge.arrow.width = .5)
```
